{"title":"当前明月的博客","description":"移动端，前端，后端，运维，全都会，如果你认为啥都会就等于啥都不会，那你就错了，哥不仅会还精通，你说气人不。","language":"","link":"http://example.com","pubDate":"Tue, 10 Dec 2019 10:51:13 GMT","lastBuildDate":"Mon, 11 Jan 2021 13:55:15 GMT","generator":"hexo-generator-json-feed","webMaster":"当前明月","items":[{"title":"swift 模式匹配","link":"http://example.com/2019/12/10/swift-模式匹配/","description":"一 模式定义模式是用于匹配的规则,比如switch的case, 捕捉错误的catch, if\\guard\\while\\for语句的条件等,swift中的模式有 通配符模式 标识符模式 值绑定模式 元组模式 枚举Case模式 可选模式 类型转换模式 表达式模式 下面让我们一一讲解这些模式","pubDate":"Tue, 10 Dec 2019 10:51:13 GMT","guid":"http://example.com/2019/12/10/swift-模式匹配/","category":"swift"},{"title":"swift 字面量","link":"http://example.com/2019/12/07/swift-字面量/","description":"一 字面量123var age = 10var isBlue = falsevar name = \"Lisa\" 上面的代码中的10,false,“Jack”就是字面量,那字面量它们都是属于什么类型呢,请接着往下看 二 字面量类型1234567891011public typealias Float32 = Floatpublic typealias Float64 = Doublepublic typealias IntegerLiteralType = Intpublic typealias FloatLiteralType = Doublepublic typealias BooleanLiteralType = Boolpublic typealias StringLiteralType = String swift 自带的绝大部分类型,都支持直接通过字面量进行初始化,比如: Bool, Int, Float, Double,String,Array, Dictionary,Set,Optional等, 我们可以通过typealias修改字面量的默认类型","pubDate":"Sat, 07 Dec 2019 05:53:23 GMT","guid":"http://example.com/2019/12/07/swift-字面量/","category":"swift"},{"title":"swift 指针","link":"http://example.com/2019/12/05/swift-指针/","description":"swift中也有专门的指针类型,这些都被定性为“unsafe”(不安全的),常见的有以下4种类型: UnsafePointer类似于const Pointee * UnsafeMutablePointer 类似于Pointee * UnsafeRawPointer类似于 const void * UnsafeMutableRawPointer 类似于void * 下面我们一一讲解这四种类型 一 UnsafePointer12345678var age = 10func test(_ ptr: UnsafePointer&lt;Int&gt;) &#123; print(\"变量地址:\", ptr) print(\"变量存放的内容:\",ptr.pointee)&#125;test(&amp;age)//变量地址: 0x0000000100002048//变量存放的内容: 10 UnsafePointer只用来去访问内存,支持泛型,不可以去修改内存,对于一个变量它指向的是变量的内存地址 二 UnsafeMutablePointer1234567891011var age = 10func test(_ ptr: UnsafeMutablePointer&lt;Int&gt;) &#123; print(\"变量地址:\", ptr) print(\"变量存放的内容:\",ptr.pointee) ptr.pointee = 20&#125;test(&amp;age)print(age)//变量地址: 0x0000000100002048//变量存放的内容: 10//20 UnsafePointer用来去访问内存,支持泛型,可以去修改内存,对于一个变量它指向的是变量的内存地址","pubDate":"Thu, 05 Dec 2019 13:37:34 GMT","guid":"http://example.com/2019/12/05/swift-指针/","category":"swift"},{"title":"swift 内存管理","link":"http://example.com/2019/12/01/swift-内存管理/","description":"一 内存管理概览跟OC一样,Swift 也是采用基于引用计数的ARC内存管理方案,这里讲的都是针对堆空间, Swift的ARC中有3种引用 1 强引用(strong reference): 默认情况下,引用都是强引用 1234567891011class Person &#123; deinit &#123; print(\"Person deinit\") &#125;&#125;func test() &#123; let p = Person() //强引用&#125;print(1)test()print(2) 2 弱引用(weak refernce): 通过weak定义弱引用 1234567891011class Person &#123; deinit &#123; print(\"Person deinit\") &#125;&#125;func test() &#123; weak var p:Person? = Person() //强引用&#125;print(1)test()print(2) 必须是可选类型的var,因为实例销毁后,ARC会自动将弱引用设置为nil,此外ARC自动给弱引用设置nil时,不会触发属性观察器","pubDate":"Sun, 01 Dec 2019 13:24:45 GMT","guid":"http://example.com/2019/12/01/swift-内存管理/","category":"swift"},{"title":"swift 访问控制","link":"http://example.com/2019/11/30/swift-访问控制/","description":"一 访问控制五个级别在访问控制这块,Swift提供了5个不同的访问级别 如下: open: 允许在定义实体的模块,其它模块中访问,允许其他模块进行继承,重写(open 只能用在类及类成员上) public: 允许在定义实体的模块,其它模块中访问, 不允许其他模块进行继承重写 internal: 只允许在定义实体的模块中访问,不允许在其他模块中访问 fileprivate: 只允许在定义实体的源文件中访问 private: 只允许在定义实体的封闭声明中访问 绝大部分实体默认都是internal级别","pubDate":"Sat, 30 Nov 2019 12:38:03 GMT","guid":"http://example.com/2019/11/30/swift-访问控制/","category":"swift"},{"title":"swift 扩展","link":"http://example.com/2019/11/30/swift-扩展/","description":"一 扩展初识123456789101112131415161718extension Double &#123; var km: Double &#123;self * 1_000.0&#125; var m: Double &#123;self&#125; var dm: Double &#123; self / 10.0&#125; var cm: Double &#123;self / 100.0&#125; var mm: Double &#123;self / 1_000.0&#125;&#125;var am:Double = 1000print(am.km)print(am.m)print(am.dm)print(am.cm)print(am.mm)//1000000.0//1000.0//100.0//10.0//1.0 swift中的扩展类似于OC的分类,可以为枚举,结构体,类,协议添加方法,计算属性,下标 ,便捷初始化器,嵌套类型,协议等,扩展还有一些注意⚠️事项","pubDate":"Sat, 30 Nov 2019 05:15:50 GMT","guid":"http://example.com/2019/11/30/swift-扩展/","category":"swift"},{"title":"swift 运算符重载","link":"http://example.com/2019/11/25/swift-运算符重载/","description":"一 溢出运算符(Overflow Operator)1234print(Int8.min) //-128print(Int8.max) //127var a:Int8 = 10var b:Int8 = a * 100//❌ 超出范围 swift的算数运算符出现溢出时会抛出运行时错误 1234567var min = UInt8.minprint(min) //0print(min &amp;- 1) //255var max = UInt8.maxprint(max &amp;+ 1) //0print(max &amp;* 2) //254 swift有溢出运算符 &amp;+ , &amp;-, &amp;* ,用来支持溢出运算,溢出运算超出类型返回,会自动循环♻️从零开始","pubDate":"Mon, 25 Nov 2019 13:15:15 GMT","guid":"http://example.com/2019/11/25/swift-运算符重载/","category":"swift"},{"title":"swift 泛型","link":"http://example.com/2019/11/22/swift-泛型/","description":"一 泛型初识,写一个泛型函数1234567891011func swapValues&lt;T&gt;(_ a:inout T, _ b:inout T)&#123; (a,b) = (b,a)&#125;var i1 = 10var i2 = 20swap(&amp;i1, &amp;i2)print(\"i1=\\(i1),i2=\\(i2)\")var i3 = \"hello\"var i4 = \"world\"swap(&amp;i3, &amp;i4)print(\"i3=\\(i3),i4=\\(i4)\") 泛型可以将类型参数化,提高代码复用率,减少代码量 12345678func swapValues&lt;T&gt;(_ a:inout T, _ b:inout T)&#123; (a,b) = (b,a)&#125;var i1 = 10var i2 = 20var fn:(inout Int,inout Int)-&gt;() = swapfn(&amp;i1, &amp;i2)print(\"i1=\\(i1),i2=\\(i2)\")//i1=20,i2=10 泛型类型赋值给变量要制定好类型fn:(inout Int,inout Int)-&gt;()","pubDate":"Fri, 22 Nov 2019 12:45:04 GMT","guid":"http://example.com/2019/11/22/swift-泛型/","category":"swift"},{"title":"swift 错误处理","link":"http://example.com/2019/11/20/swift-错误处理/","description":"一 开发中常见的错误 语法错误 12let age = 10age += 20 //❌ 逻辑错误 123if age &gt; 10 &#123; age = 10&#125; 运行时错误(闪退,异常等) 1234 func divide(_ num1:Int, _ num2:Int) -&gt; Int &#123; num1 / num2&#125;print(divide(10, 0))","pubDate":"Wed, 20 Nov 2019 12:50:45 GMT","guid":"http://example.com/2019/11/20/swift-错误处理/","category":"swift"},{"title":"swift 元类型","link":"http://example.com/2019/11/15/swift-元类型/","description":"一 初识元类型swift提供了两种特殊的类型:Any, AnyObject Any: 可以代表任意类型 123456 class Student&#123; &#125;var stu:Any = 10stu = \"Jack\"stu = Student() stu是Any类型,赋值给它啥都行 AnyObject:可以代表任意类类型 123456789protocol Runnable:AnyObject &#123; &#125;class Person: Runnable &#123; &#125;struct Size: Runnable &#123; //❌ &#125; 在协议后面写上AnyObect 代表只有类才能遵守这个协议","pubDate":"Fri, 15 Nov 2019 12:52:44 GMT","guid":"http://example.com/2019/11/15/swift-元类型/","category":"swift"},{"title":"swift 协议","link":"http://example.com/2019/11/12/swift-协议/","description":"一 初识协议12345678910111213141516171819202122232425262728293031protocol Drawble &#123; func draw() var x: Int &#123; get set&#125; var y: Int &#123; get &#125; subscript(index:Int)-&gt;Int &#123; get set &#125;&#125;protocol Test1 &#123; &#125;class TestCase: Drawble,Test1 &#123; func draw() &#123; &#125; var x: Int var y: Int init(x:Int,y:Int) &#123; self.x = x self.y = y &#125; subscript(index: Int) -&gt; Int &#123; get &#123; index &#125; set &#123; &#125; &#125;&#125; 使用protocol来声明一个协议,协议可以用来定义方法,属性,下标的声明,协议可以被枚举,结构体,类遵守(多个协议之间用逗号分隔) 协议中定义方法时不能有默认参数值","pubDate":"Tue, 12 Nov 2019 11:31:51 GMT","guid":"http://example.com/2019/11/12/swift-协议/","category":"swift"},{"title":"swift 可选链","link":"http://example.com/2019/10/25/swift-可选链/","description":"123456789101112131415161718192021222324252627282930class Car &#123; var price = 0&#125;class Dog&#123; var weight = 0&#125;class Person &#123; var name:String = \"\" var dog:Dog = Dog() var car:Car? = Car() func age() -&gt; Int &#123; 20 &#125; func eat() &#123; print(\"person eat\") &#125; func getName() -&gt; String &#123; return name &#125; subscript(index:Int)-&gt;Int&#123; index &#125;&#125;var person: Person? = Person()var age1 = person!.age()//Intvar age2 = person?.age()//Int?var name = person?.name //String?var index = person?[6]//Int?person?.name = person?.getName() as! String 如果可选项为nil,调用方法,下标,属性失败,结果为nil 如果可选项不为nil,调用方法,下标,属性成功,结果会被包装成可选项 如果结果本来就是可选项,不会进行再次包装","pubDate":"Fri, 25 Oct 2019 10:52:27 GMT","guid":"http://example.com/2019/10/25/swift-可选链/","category":"swift"},{"title":"swift 初始化器","link":"http://example.com/2019/10/20/swift-初始化器/","description":"一 初始化器种类(只针对一类)12345678910111213141516struct Ract &#123; var width:Int = 0 var height:Int = 0 init(width:Int) &#123; self.width = width &#125;&#125;class Size &#123; var width:Int = 0 var height:Int = 0 init(width:Int) &#123; self.width = width &#125;&#125;var s = Size(width: 10) 类,结构体,枚举都可以定义初始化器 123456class Size &#123; var width:Int = 0 var height:Int = 0 &#125;var s = Size() 如果我们没有指定初始化器,编译器会默认给我们生成一个初始化器,如果我们指定了初始化器,编译器不会再给我们生成默认的,指定初始化器,要保证类的成员变量都能够初始化","pubDate":"Sun, 20 Oct 2019 08:39:04 GMT","guid":"http://example.com/2019/10/20/swift-初始化器/","category":"swift"},{"title":"swift 多态","link":"http://example.com/2019/10/15/swift-多态/","description":"一 多态概念12345678910111213141516171819202122232425262728293031323334353637383940414243 class Animal &#123; func speak() &#123; print(\"Animal speak\") &#125; func eat() &#123; print(\"Animal eat\") &#125; func sleep() &#123; print(\"Animal sleep\") &#125;&#125;class Dog:Animal &#123; override func speak() &#123; print(\"Dog speak\") &#125; override func eat() &#123; print(\"Dog eat\") &#125; func run() &#123; print(\"Dog run\") &#125;&#125;var anim = Animal()anim.speak()anim.eat()anim.sleep()print(\"----------\")anim = Dog()anim.speak()anim.eat()anim.sleep()//Animal speak//Animal eat//Animal sleep//----------//Dog speak//Dog eat//Animal sleep 多态: 父类型的引用指向子类型的对象","pubDate":"Tue, 15 Oct 2019 02:39:04 GMT","guid":"http://example.com/2019/10/15/swift-多态/","category":"swift"},{"title":"swift 继承","link":"http://example.com/2019/10/06/swift-继承/","description":"一 继承初探123456class Animal &#123; var age = 0&#125;class Dog:Animal &#123; var weight = 0&#125; 定义类在类名后加:父类 就形成了继承关系. 值类型不支持继承,只有类支持继承(枚举,结构体都不支持继承) 没有父类的类称基类,swift不像OC那样任何类最终都要继承自某个基类","pubDate":"Sun, 06 Oct 2019 06:56:29 GMT","guid":"http://example.com/2019/10/06/swift-继承/","category":"swift"},{"title":"swift 下标","link":"http://example.com/2019/10/01/swift-下标/","description":"一 下标的定义12345678910111213141516171819202122232425class Point &#123; var x=0.0, y=0.0 subscript(index:Int) -&gt;Double &#123; set &#123; if index % 2 == 0 &#123; x = newValue &#125; else &#123; y = newValue &#125; &#125; get &#123; if index % 2 == 0 &#123; return x &#125; else &#123; return y &#125; &#125; &#125;&#125;var p = Point()p[0] = 22.2p[1] = 33.3print(p.x,p[0]) //22.2 22.2print(p.y,p[1]) //33.3 33.3 使用subscript可以给任意类型,枚举,结构体,类增加下标功能,也可叫做下标脚本 subscript 中定义的返回值类型决定了: get方法的返回值类型 set方法中newValue的类型","pubDate":"Tue, 01 Oct 2019 03:44:11 GMT","guid":"http://example.com/2019/10/01/swift-下标/","category":"swift"},{"title":"swift 方法","link":"http://example.com/2019/09/30/swift-方法/","description":"一 方法简介方法分为实例方法和类型方法,枚举,结构体,类都可以定义实例方法,类型方法 实例方法: 通过实例对象调用 类型方法: 通过类型调用,用static或者class关键字定义 二 实例方法123456789101112class Car &#123; var count:Int init() &#123; self.count = 0 &#125; func getCount() -&gt; Int &#123; self.count &#125;&#125;let car = Car()car.count = 20print(car.getCount())//20 实例方法中,self代表实例对象","pubDate":"Mon, 30 Sep 2019 03:44:11 GMT","guid":"http://example.com/2019/09/30/swift-方法/","category":"swift"},{"title":"swift 属性","link":"http://example.com/2019/09/15/swift-属性/","description":"swift 属性分为两大类: 实例属性和类型属性,.实例属性又分为:存储实例属性和计算实例属性, 类型属性分为: 存储类型属性和计算类型属性 一 实例存储属性123456789101112131415struct Point &#123; var x:Int var y:Int&#125;var p = Point(x:10,y:20)print(MemoryLayout.stride(ofValue: p))class Circle &#123; var x:Int var y:Int init(x:Int,y:Int) &#123; self.x = x self.y = y &#125;&#125; 相当于成员变量,属性存储在实例的内存中,只有结构体和类可以定义实例存储属性,枚举不可以定义存储属性. 1 枚举为什么不可以定义存储属性呢? 首先存储属性是存储在实例内存中的,而枚举实例值存储了case相关值标识,比如枚举原始值,只占1个字节,这里的枚举是无法存储你定义其它非case变量的","pubDate":"Sun, 15 Sep 2019 09:00:30 GMT","guid":"http://example.com/2019/09/15/swift-属性/","category":"swift"},{"title":"swift 闭包","link":"http://example.com/2019/09/02/swift-闭包/","description":"一 闭包的定义1234567891011typealias Fn = (Int) -&gt; Intfunc getFn() -&gt;Fn &#123; var num = 0; func plus(_ i:Int) -&gt; Int&#123; num += i return num &#125; return plus&#125; // 返回的plus和num形成了闭包var fn1 = getFn()print(fn1(1)) //1 一个函数和它所捕获的变量或常量环境组合起来，称为 闭包 一般指定义在函数内部的函数 一般它捕获的是外层函数的局部变量或常量","pubDate":"Mon, 02 Sep 2019 07:04:23 GMT","guid":"http://example.com/2019/09/02/swift-闭包/","category":"swift"},{"title":"swift 结构体和类","link":"http://example.com/2019/09/01/swift-结构体和类/","description":"一 结构体12345678 struct Date &#123; var year: Int var month: Int var day: Int&#125;var date = Date(year: 2019, month: 6, day: 20)print(date.year,date.month,date.day)//2019 6 20//Program ended with exit code: 0 swift标准库中，绝大多数的公开类型都是结构体，枚举只占很小一部分，像，Bool, Int, Double, String, Array, Dictionary等常见类型都是结构体 二 结构体的初始化器 ❌错误改正图片中最后一个date4 要改成date5，提示是对的 所有的结构体都有一个编译器自动生成的初始化器（initializer） 编译器会根据情况，可能会为结构体生成多个初始化器，它要保证所有成员都有初始值 1234567891011struct Date &#123; var year: Int? var month: Int? var day: Int?&#125;var date = Date(year: 2019, month: 6, day: 20)var date2 = Date(year: 2019)var date3 = Date(month: 6)var date4 = Date(day: 20)var date5 = Date() 这个会报错么，能编译通过么？？ 不会报错，可选项都有个默认值nil，编译器会生成多个初始化方法，同时它也能保证所有变量都有初始值","pubDate":"Sun, 01 Sep 2019 02:40:23 GMT","guid":"http://example.com/2019/09/01/swift-结构体和类/","category":"swift"},{"title":"swift枚举","link":"http://example.com/2019/08/28/swift枚举/","description":"一 枚举的基本用法12345678910111213141516171819202122232425enum Direction &#123; case north case south case east case west&#125;var dir = Direction.westdir = .northprint(dir)enum Season &#123; case spring, summer,autumn, winter&#125;var season = Season.summerswitch season &#123;case .spring: print(\"spring\")case .summer: print(\"summer\")case .autumn: print(\"autumn\")case .winter: print(\"winter\")&#125; 对于有限固定值的定义成枚举比较合适,比如,季节,请求状态,物流流转状态,订单状态,等等 二 关联值1234567891011121314enum Score &#123; case points(Int) case grade(Character)&#125;var score = Score.points(96)score = .grade(\"A\")switch score &#123;case let .points(point): print(point)case .grade(var grade): grade = \"B\" print(grade)&#125;//B//Program ended with exit code: 0 可在.points前面整体定义 它定义什么类型，那三个变量就是什么类型，var 或let,也可以单独定义比如.grade关联值是存储在枚举变量内存里面的 123456789101112enum Password &#123; case number(Int,Int,Int,Int) case gesture(String)&#125;var pwd = Password.number(5, 9, 8, 6)pwd = .gesture(\"13456\")switch pwd &#123;case let .number(n1, n2, n3, n4): print(n1,n2,n3,n4)case .gesture(let gesture): print(gesture)&#125; 密码有数字密码和手势密码,这两种方式是固定的,对于有限固定值我们定义成枚举,但是每个人定义设定的数字和手势密码都不同,那我们就定义几个关联值,与这个枚举进行关联","pubDate":"Wed, 28 Aug 2019 02:45:49 GMT","guid":"http://example.com/2019/08/28/swift枚举/","category":"swift"},{"title":"swift 可选项(Optional)","link":"http://example.com/2019/08/21/swift-可选项-Optional/","description":"一 可选项定义12345678910111213141516171819var name:String? = \"Jack\"name = nilvar age:Int?age = 10age = nilvar array = [1,15,40,29]func get(_ index:Int) -&gt; Int? &#123; if index &lt; 0 || index &gt;= array.count &#123; return nil &#125; return array[index]&#125;print(get(1))print(get(-1))print(get(4))//Optional(15)//nil//nil 可选项,一般也叫可选类型,它允许将值设置为nil,在类型名称后面加个问号❓来定义一个可选项, 通过打印我们看到可选项打印出来是Optional(15),那么这个Optional(15)我们该怎么用呢 二 强制解包12345var age:Int? = 10var ageInt:Int = age!ageInt += 10print(ageInt)//20//Program ended with exit code: 0 如果要从可选项中取出被包装的数据,需要使用感叹号❕ 对值为nil的可选项进行强制解包,将会产生运行时错误 判断可选项是否包含值123456let number = Int(\"123\")if number != nil&#123; print(\"字符串转换整数成功:\\(number)\")&#125; else &#123; print(\"字符串转换整数失败\")&#125;//字符串转换整数成功:Optional(123)","pubDate":"Wed, 21 Aug 2019 11:32:28 GMT","guid":"http://example.com/2019/08/21/swift-可选项-Optional/","category":"swift"},{"title":"swift函数","link":"http://example.com/2019/08/15/swift函数/","description":"一 函数的定义12345678910111213141516171819//无参有返回值func pi() -&gt; Double &#123; return 3.1415926&#125;//有参有返回值func sum(v1:Int, v2:Int) -&gt; Int &#123; return v1 + v2&#125;//无参无返回值func sayHello() -&gt; Void &#123; print(\"hello\")&#125;//有参无返回值func sayWorld(v1:Int) &#123; print(v1)&#125; 形参默认是let,也只能是let 二 函数的文档注释返回多个值12345678910111213////// 返回两个数的和 差 平均值////// - Parameter v1: 第一个整数/// - Parameter v2: 第二个整数/// - Returns: sum:Int, difference:Int, average:Int////// - Note:通过一个元组实现多返回值func calculate(v1:Int, v2:Int) -&gt; (sum:Int, difference:Int, average:Int) &#123; let sum = v1 + v2 return (sum,v1-v2, sum &gt;&gt; 1)&#125;let result = calculate(v1: 20, v2: 10) 对着函数调用按住option键即可查看注释效果 更多注释规范 点此查看","pubDate":"Thu, 15 Aug 2019 10:59:24 GMT","guid":"http://example.com/2019/08/15/swift函数/","category":"swift"},{"title":"swift流程控制","link":"http://example.com/2019/08/10/swift流程控制/","description":"一 if else12345678let age = 30if age &gt;= 22 &#123; print(\"Get married\")&#125; else if age &gt;= 18 &#123; print(\"Being a adult\")&#125; else &#123; print(\"listening tu ta zi jiao huan\")&#125; if 后面的条件可以省略小括号条件后面的大括号不可以省略if 后面的条件只能是Bool类型 二 while12345678910var num = 5while num &gt; 0 &#123; print(\"num is \\(num)\") num -= 1&#125;var num2 = -1repeat &#123; print(\"num2 is \\(num2)\")&#125; while num2 &gt; 0 repeat-while相当于C语言中的do-while从Swift3开始,去除了自增(++),自减(–)运算符,为啥去除呢,可能为了更严谨吧. 123var number = 0let b = ++ number + number++print(b) //?? 你能快速算出b是几么? swift去除自增自减,也是为了更明确简洁吧.","pubDate":"Sat, 10 Aug 2019 09:15:16 GMT","guid":"http://example.com/2019/08/10/swift流程控制/","category":"swift"},{"title":"swift基础语法","link":"http://example.com/2019/07/30/swift基础语法/","description":"一 Hello World二 注释三 常量四 标识符五 常见数据类型六 字面量七 元组一 Hellow World1234func helloworld() &#123; print(\"hello world\")&#125;print(\"你好,世界\") 12output: 你好,世界Program ended with exit code: 0 1 不用像OC那样需要main函数,Swift会将全局内的首句可执行代码作为程序入口, 其实它还是有main函数的,底层做的,不需要我们手动写了 2 相比OC我们语句后面也不用写 “ ; ”了,但是多个语句在一行还是需要的. 12345678let a = 10var b = 20b = 100//a = 100 xxxprint(a,b)10 100Program ended with exit code: 0 1 用var 定义变量, 变量可修改值 2 用let 定义常量,值不可修改 有点像javasript常 变量的定义","pubDate":"Tue, 30 Jul 2019 05:42:31 GMT","guid":"http://example.com/2019/07/30/swift基础语法/","category":"swift"}]}