{"title":"当前明月的博客","description":"移动端，前端，后端，运维，全都会，如果你认为啥都会就等于啥都不会，那你就错了，哥不仅会还精通，你说气人不。","language":"","link":"http://example.com","pubDate":"Sun, 06 Dec 2020 06:56:29 GMT","lastBuildDate":"Sun, 06 Dec 2020 12:49:45 GMT","generator":"hexo-generator-json-feed","webMaster":"当前明月","items":[{"title":"swift 继承","link":"http://example.com/2020/12/06/swift-继承/","description":"一 继承初探123456class Animal &#123; var age = 0&#125;class Dog:Animal &#123; var weight = 0&#125; 定义类在类名后加:父类 就形成了继承关系. 值类型不支持继承,只有类支持继承(枚举,结构体都不支持继承) 没有父类的类称基类,swift不像OC那样任何类最终都要继承自某个基类 二 继承后类实例的内存结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Animal &#123; var age = 0&#125;class Dog:Animal &#123; var weight = 0&#125;class ErVa:Dog &#123; var iq = 0&#125;let a = Animal()a.age = 10print(Mems.size(ofRef: a))print(Mems.memStr(ofRef: a))/* 0x0000000100008418 0x0000000000000002 0x000000000000000a //age 0x0000000000000000 */let d = Dog()d.age = 10d.weight = 20print(Mems.size(ofRef: d)) //32print(Mems.memStr(ofRef: d))/* 0x00000001000084c8 0x0000000000000002 0x000000000000000a //age 0x0000000000000014 //weight */let e = ErVa()e.age = 10e.weight = 20e.iq = 30print(Mems.size(ofRef: e)) //48print(Mems.memStr(ofRef: e))/* 0x0000000100008598 0x0000000000000002 0x000000000000000a //age 0x0000000000000014 //weight 0x000000000000001e //iq 0x0000000000000000 */ 子类继承父类的存储属性,都会在自己的内存中保存一份 三 重写实例方法,下标123456789101112131415161718192021222324class Cat: Animal &#123; override func speak() &#123; super.speak() print(\"Cat speak\") &#125; override subscript(index: Int) -&gt; Int &#123; return super[index] + 1 &#125;&#125;var anim:Animalanim = Animal()anim.speak()print(anim[6])//Animal speak//6anim = Cat()anim.speak()print(anim[6])//Animal speak//Cat speak//7 四 重写类型方法,下标1234567891011121314151617181920212223242526272829class Animal &#123; class func speak() &#123; print(\"Animal speak\") &#125; class subscript(index:Int) -&gt; Int &#123; return index &#125;&#125;class Cat: Animal &#123; override class func speak() &#123; super.speak() print(\"Cat speak\") &#125; override static subscript(index: Int) -&gt; Int &#123; return super[index] + 1 &#125;&#125;Animal.speak()print(Animal[6])//Animal speak//6Cat.speak()print(Cat[6])//Animal speak//Cat speak//7 被class修饰的类型方法,下标,允许被子类重写 被static修饰的类型方法,下标,不允许被子类重写 五 重写属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455子类可以将父类的属性(存储属性,计算属性)重写为计算属性class Animal &#123; var name:String=\"\" var age:Int &#123; get&#123; return 0 &#125; &#125;&#125;class Cat: Animal &#123; override var name: String&#123; get&#123; return \"Dog\" &#125; set &#123; &#125; &#125; override var age: Int&#123; get &#123; return 10 &#125; &#125;&#125;-----------------子类不可以将父类属性重写为存储属性class Animal &#123; var name:String=\"\"&#125;class Cat: Animal &#123; override var name: String=\"\" //❌&#125;------------------只能重写var属性, 不能重写let属性class Animal &#123; let name:String=\"\"&#125;class Cat: Animal &#123; override var name: String&#123; //❌ get&#123; return \"Dog\" &#125; set &#123; &#125; &#125;&#125; 子类可以将父类的属性(存储、计算)重写为计算属性 子类不可以将父类属性重写为存储属性 只能重写var属性，不能重写let属性 重写时，属性名、类型要一致 子类重写后的属性权限 不能小于 父类属性的权限 如果父类属性是只读的，那么子类重写后的属性可以是只读的、也可以是可读写的 如果父类属性是可读写的，那么子类重写后的属性也必须是可读写的 六 重写类型属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Circle &#123; static var radiu:Int = 0 class var diameter:Int &#123; set &#123; print(\"Circle setDiameter\") radiu = newValue / 2 &#125; get &#123; print(\"Circle getDiameter\") return radiu * 2 &#125; &#125;&#125;class SubCircle: Circle &#123; override static var diameter: Int&#123; set &#123; print(\"SubCircle setDiameter\") super.diameter = newValue &gt; 0 ? newValue : 0 &#125; get &#123; print(\"Subcircle getDiameter\") return super.diameter &#125; &#125;&#125;Circle.radiu = 6print(Circle.diameter)Circle.diameter = 20print(Circle.radiu)print(\"----------------\")SubCircle.radiu = 6print(SubCircle.diameter)SubCircle.diameter = 20print(SubCircle.radiu)//Circle getDiameter//12//Circle setDiameter//10//----------------//Subcircle getDiameter//Circle getDiameter//12//SubCircle setDiameter//Circle setDiameter//10 被 class 修饰的计算属性,可以被子类重写 被static修饰的类型属性(存储,计算),不可以被子类重写 七 添加属性观察器123456789101112131415class Circle &#123; var radius: Int = 1&#125;class SubCircle : Circle &#123; override var radius:Int &#123; willSet &#123; print(\"SubCircle willSetRadius\", newValue) &#125; didSet &#123; print(\"SubCircle didSetRadius\", oldValue,radius) &#125; &#125;&#125;var circle = SubCircle()circle.radius = 10 可以在子类中为父类属性(除了只读计算属性,let属性)增加属性观察器 123456789101112131415161718192021222324252627class Circle &#123; var radius: Int = 1 &#123; willSet &#123; print(\"Circle willSetRadius\", newValue) &#125; didSet &#123; print(\"Circle didSetRadius\", oldValue,radius) &#125; &#125;&#125;class SubCircle : Circle &#123; override var radius:Int &#123; willSet &#123; print(\"SubCircle willSetRadius\", newValue) &#125; didSet &#123; print(\"SubCircle didSetRadius\", oldValue,radius) &#125; &#125;&#125;var circle = SubCircle()circle.radius = 10//SubCircle willSetRadius 10//Circle willSetRadius 10//Circle didSetRadius 1 10//SubCircle didSetRadius 1 10//Program ended with exit code: 0 父类子类都有属性观察器的情况, 先调用子类willset 然后调用父类willset 接着调用父类didset 最后调用子类didset 12345678910111213141516171819202122232425262728class Circle &#123; var radius: Int &#123; set &#123; print(\"Circle willSetRadius\", newValue) &#125; get &#123; print(\"Circle getRadius\") return 20 &#125; &#125;&#125;class SubCircle : Circle &#123; override var radius:Int &#123; willSet &#123; print(\"SubCircle willSetRadius\", newValue) &#125; didSet &#123; print(\"SubCircle didSetRadius\", oldValue,radius) &#125; &#125;&#125;var circle = SubCircle()circle.radius = 10//Circle getRadius//SubCircle willSetRadius 10//Circle willSetRadius 10//Circle getRadius//SubCircle didSetRadius 20 20 Circle getRadius 是为了获取oldValue willset前要先获取它原来的值 12345678910111213141516171819202122232425262728class Circle &#123; class var radius: Int &#123; set &#123; print(\"Circle willSetRadius\", newValue) &#125; get &#123; print(\"Circle getRadius\") return 20 &#125; &#125;&#125;class SubCircle : Circle &#123; override static var radius:Int &#123; willSet &#123; print(\"SubCircle willSetRadius\", newValue) &#125; didSet &#123; print(\"SubCircle didSetRadius\", oldValue,radius) &#125; &#125;&#125;SubCircle.radius = 10//Circle getRadius//SubCircle willSetRadius 10//Circle willSetRadius 10//Circle getRadius//SubCircle didSetRadius 20 20 八 final12345678910111213141516171819202122class Circle &#123; final var radius: Int &#123; set &#123; print(\"Circle willSetRadius\", newValue) &#125; get &#123; print(\"Circle getRadius\") return 20 &#125; &#125;&#125;class SubCircle : Circle &#123; override var radius:Int &#123; //❌ willSet &#123; print(\"SubCircle willSetRadius\", newValue) &#125; didSet &#123; print(\"SubCircle didSetRadius\", oldValue,radius) &#125; &#125;&#125; 被final修饰的方法,下标,属性,禁止被重写被final修饰的类,禁止被继承","pubDate":"Sun, 06 Dec 2020 06:56:29 GMT","guid":"http://example.com/2020/12/06/swift-继承/","category":"swift"},{"title":"swift 下标","link":"http://example.com/2019/10/01/swift-下标/","description":"一 下标的定义12345678910111213141516171819202122232425class Point &#123; var x=0.0, y=0.0 subscript(index:Int) -&gt;Double &#123; set &#123; if index % 2 == 0 &#123; x = newValue &#125; else &#123; y = newValue &#125; &#125; get &#123; if index % 2 == 0 &#123; return x &#125; else &#123; return y &#125; &#125; &#125;&#125;var p = Point()p[0] = 22.2p[1] = 33.3print(p.x,p[0]) //22.2 22.2print(p.y,p[1]) //33.3 33.3 使用subscript可以给任意类型,枚举,结构体,类增加下标功能,也可叫做下标脚本 subscript 中定义的返回值类型决定了: get方法的返回值类型 set方法中newValue的类型 二 下标的本质1234567891011121314151617181920212223class Point &#123; var x=0.0, y=0.0 subscript(index:Int) -&gt;Double &#123; set &#123; if index % 2 == 0 &#123; x = newValue &#125; else &#123; y = newValue &#125; &#125; get &#123; if index % 2 == 0 &#123; return x &#125; else &#123; return y &#125; &#125; &#125;&#125;var p = Point()p[0] = 22.2let x = p[0] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 0x100001904 &lt;+132&gt;: xorl %r8d, %r8d 0x100001907 &lt;+135&gt;: movl %r8d, %edi 0x10000190a &lt;+138&gt;: movq -0x60(%rbp), %rax 0x10000190e &lt;+142&gt;: movq (%rax), %rcx 0x100001911 &lt;+145&gt;: movq %rax, %r13 0x100001914 &lt;+148&gt;: callq *0x90(%rcx) //调用get方法 0x10000191a &lt;+154&gt;: movq -0x60(%rbp), %rdi 0x10000191e &lt;+158&gt;: callq 0x10000634c ; symbol stub for: swift_release 0x100001923 &lt;+163&gt;: leaq 0x6aae(%rip), %rax ; sudy.p : sudy.Point 0x10000192a &lt;+170&gt;: xorl %r8d, %r8d 0x10000192d &lt;+173&gt;: movl %r8d, %ecx 0x100001930 &lt;+176&gt;: movq %rax, %rdi 0x100001933 &lt;+179&gt;: leaq -0x38(%rbp), %rsi 0x100001937 &lt;+183&gt;: movl $0x20, %edx 0x10000193c &lt;+188&gt;: callq 0x1000062e0 ; symbol stub for: swift_beginAccess 0x100001941 &lt;+193&gt;: movq 0x6a90(%rip), %rax ; sudy.p : sudy.Point 0x100001948 &lt;+200&gt;: movq %rax, %rcx 0x10000194b &lt;+203&gt;: movq %rcx, %rdi 0x10000194e &lt;+206&gt;: movq %rax, -0x70(%rbp) 0x100001952 &lt;+210&gt;: callq 0x100006352 ; symbol stub for: swift_retain 0x100001957 &lt;+215&gt;: leaq -0x38(%rbp), %rdi 0x10000195b &lt;+219&gt;: movq %rax, -0x78(%rbp) 0x10000195f &lt;+223&gt;: callq 0x100006304 ; symbol stub for: swift_endAccess 0x100001964 &lt;+228&gt;: xorl %r8d, %r8d 0x100001967 &lt;+231&gt;: movl %r8d, %edi 0x10000196a &lt;+234&gt;: movq -0x70(%rbp), %rax 0x10000196e &lt;+238&gt;: movq (%rax), %rcx 0x100001971 &lt;+241&gt;: movq %rax, %r13 0x100001974 &lt;+244&gt;: callq *0xa0(%rcx) //调用set方法 0x10000197a &lt;+250&gt;: movsd %xmm0, 0x6a5e(%rip) ; sudy.x : Swift.Double 0x100001982 &lt;+258&gt;: movq -0x70(%rbp), %rdi 0x100001986 &lt;+262&gt;: callq 0x10000634c ; symbol stub for: swift_release 0x10000198b &lt;+267&gt;: xorl %eax, %eaxsudy`Point.subscript.setter:-&gt; 0x100001e10 &lt;+0&gt;: pushq %rbp 0x100001e11 &lt;+1&gt;: movq %rsp, %rbp 0x100001e14 &lt;+4&gt;: pushq %r13 0x100001e16 &lt;+6&gt;: subq $0x48, %rsp 0x100001e1a &lt;+10&gt;: xorl %eax, %eax 0x100001e1c &lt;+12&gt;: leaq -0x10(%rbp), %rcx 0x100001e20 &lt;+16&gt;: movq %rdi, -0x28(%rbp) 0x100001e24 &lt;+20&gt;: movq %rcx, %rdi 0x100001e27 &lt;+23&gt;: movl %eax, %esi 0x100001e29 &lt;+25&gt;: movl $0x8, %ecx 0x100001e2e &lt;+30&gt;: movq %rcx, %rdx sudy`Point.subscript.getter:-&gt; 0x100001fc0 &lt;+0&gt;: pushq %rbp 0x100001fc1 &lt;+1&gt;: movq %rsp, %rbp 0x100001fc4 &lt;+4&gt;: pushq %r13 0x100001fc6 &lt;+6&gt;: subq $0x38, %rsp 0x100001fca &lt;+10&gt;: xorl %eax, %eax 0x100001fcc &lt;+12&gt;: leaq -0x10(%rbp), %rcx 0x100001fd0 &lt;+16&gt;: movq %rdi, -0x20(%rbp) 0x100001fd4 &lt;+20&gt;: movq %rcx, %rdi 0x100001fd7 &lt;+23&gt;: movl %eax, %esi 0x100001fd9 &lt;+25&gt;: movl $0x8, %ecx 0x100001fde &lt;+30&gt;: movq %rcx, %rdx 0x100001fe1 &lt;+33&gt;: movq %r13, -0x28(%rbp) 0x100001fe5 &lt;+37&gt;: movl %eax, -0x2c(%rbp) 0x100001fe8 &lt;+40&gt;: movq %rcx, -0x38(%rbp) 0x100001fec &lt;+44&gt;: callq 0x1000062ce ; symbol stub for: memset 0x100001ff1 &lt;+49&gt;: leaq -0x18(%rbp), %rcx 0x100001ff5 &lt;+53&gt;: movq %rcx, %rdi 0x100001ff8 &lt;+56&gt;: movl -0x2c(%rbp), %esi 0x100001ffb &lt;+59&gt;: movq -0x38(%rbp), %rdx 0x100001fff &lt;+63&gt;: callq 0x1000062ce ; symbol stub for: memset 0x100002004 &lt;+68&gt;: movq -0x20(%rbp), %rcx 0x100002008 &lt;+72&gt;: movq %rcx, -0x10(%rbp) 0x10000200c &lt;+76&gt;: movq -0x28(%rbp), %rdx subscript的语法类似于实例方法,计算属性,其实它的本质就是方法,既然类似于计算属性,那它就有类似计算属性的限制,比如它可以没有set方法,但必须要有get方法 1234567891011121314class Point &#123; var x=0.0, y=0.0 subscript(index:Int) -&gt;Double &#123; get &#123; if index % 2 == 0 &#123; return x &#125; else &#123; return y &#125; &#125; &#125;&#125;var p = Point()let x = p[0] 三 下标设置参数标签1234567891011121314151617181920212223class Point &#123; var x=0.0, y=0.0 subscript(index i:Int) -&gt;Double &#123; set &#123; if i % 2 == 0 &#123; x = newValue &#125; else &#123; y = newValue &#125; &#125; get &#123; if i % 2 == 0 &#123; return x &#125; else &#123; return y &#125; &#125; &#125;&#125;var p = Point()p[index:0] = 22.2let x = p[index:0] 四 类型方法下标123456class Sum &#123; static subscript(v1:Int,v2:Int) -&gt; Int &#123; return v1 + v2 &#125;&#125;print(Sum[10,20]) 只有 get , get可以省略不写 五 接受多个参数的下标1234567891011121314151617181920212223242526272829class Grid &#123; var data = [ [0,1,2], [3,4,5], [6,7,8] ] subscript(row:Int, column:Int) -&gt; Int &#123; set &#123; guard row &gt;= 0 &amp;&amp; row &lt; 3 &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; 3 else &#123; return &#125; data[row][column] = newValue &#125; get &#123; guard row &gt;= 0 &amp;&amp; row &lt; 3 &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; 3 else &#123; return 0 &#125; return data[row][column] &#125; &#125;&#125;var grid = Grid()grid[0,1] = 77grid[1,2] = 88grid[2,0] = 99print(grid.data) //[[0, 77, 2], [3, 4, 88], [99, 7, 8]] 六 下标返回值为结构体和类的差异123456789101112131415161718192021222324252627282930313233class Point &#123; var x = 0, y = 0&#125;class PointManager &#123; var point = Point() subscript(index:Int) -&gt; Point &#123; get &#123; point &#125; &#125;&#125;var pm = PointManager()pm[0].x = 11pm[0].y = 22struct Point2 &#123; var x = 0, y = 0&#125;class PointManager2 &#123; var point = Point2() subscript(index:Int) -&gt; Point2 &#123; set &#123;point = newValue&#125; //不写set方法无法赋值 赋值不用具体到具体属性 get &#123; point &#125; &#125;&#125;var pm2 = PointManager2()pm2[0].x = 33pm2[0].y = 44print(pm2[0].x,pm2[0].y) 结构体是值类型,类是指针类型,结构体下标给结构体属性赋值必须要实现set,而类不需要","pubDate":"Tue, 01 Oct 2019 03:44:11 GMT","guid":"http://example.com/2019/10/01/swift-下标/","category":"swift"},{"title":"swift 方法","link":"http://example.com/2019/09/30/swift-方法/","description":"一 方法简介方法分为实例方法和类型方法,枚举,结构体,类都可以定义实例方法,类型方法 实例方法: 通过实例对象调用 类型方法: 通过类型调用,用static或者class关键字定义 二 实例方法123456789101112class Car &#123; var count:Int init() &#123; self.count = 0 &#125; func getCount() -&gt; Int &#123; self.count &#125;&#125;let car = Car()car.count = 20print(car.getCount())//20 实例方法中,self代表实例对象","pubDate":"Mon, 30 Sep 2019 03:44:11 GMT","guid":"http://example.com/2019/09/30/swift-方法/","category":"swift"},{"title":"swift 属性","link":"http://example.com/2019/09/15/swift-属性/","description":"swift 属性分为两大类: 实例属性和类型属性,.实例属性又分为:存储实例属性和计算实例属性, 类型属性分为: 存储类型属性和计算类型属性 一 实例存储属性123456789101112131415struct Point &#123; var x:Int var y:Int&#125;var p = Point(x:10,y:20)print(MemoryLayout.stride(ofValue: p))class Circle &#123; var x:Int var y:Int init(x:Int,y:Int) &#123; self.x = x self.y = y &#125;&#125; 相当于成员变量,属性存储在实例的内存中,只有结构体和类可以定义实例存储属性,枚举不可以定义存储属性. 1 枚举为什么不可以定义存储属性呢? 首先存储属性是存储在实例内存中的,而枚举实例值存储了case相关值标识,比如枚举原始值,只占1个字节,这里的枚举是无法存储你定义其它非case变量的","pubDate":"Sun, 15 Sep 2019 09:00:30 GMT","guid":"http://example.com/2019/09/15/swift-属性/","category":"swifts"},{"title":"swift 闭包","link":"http://example.com/2019/09/02/swift-闭包/","description":"一 闭包的定义1234567891011typealias Fn = (Int) -&gt; Intfunc getFn() -&gt;Fn &#123; var num = 0; func plus(_ i:Int) -&gt; Int&#123; num += i return num &#125; return plus&#125; // 返回的plus和num形成了闭包var fn1 = getFn()print(fn1(1)) //1 一个函数和它所捕获的变量或常量环境组合起来，称为 闭包 一般指定义在函数内部的函数 一般它捕获的是外层函数的局部变量或常量","pubDate":"Mon, 02 Sep 2019 07:04:23 GMT","guid":"http://example.com/2019/09/02/swift-闭包/","category":"swift"},{"title":"swift 结构体和类","link":"http://example.com/2019/09/01/swift-结构体和类/","description":"一 结构体12345678 struct Date &#123; var year: Int var month: Int var day: Int&#125;var date = Date(year: 2019, month: 6, day: 20)print(date.year,date.month,date.day)//2019 6 20//Program ended with exit code: 0 swift标准库中，绝大多数的公开类型都是结构体，枚举只占很小一部分，像，Bool, Int, Double, String, Array, Dictionary等常见类型都是结构体 二 结构体的初始化器 ❌错误改正图片中最后一个date4 要改成date5，提示是对的 所有的结构体都有一个编译器自动生成的初始化器（initializer） 编译器会根据情况，可能会为结构体生成多个初始化器，它要保证所有成员都有初始值 1234567891011struct Date &#123; var year: Int? var month: Int? var day: Int?&#125;var date = Date(year: 2019, month: 6, day: 20)var date2 = Date(year: 2019)var date3 = Date(month: 6)var date4 = Date(day: 20)var date5 = Date() 这个会报错么，能编译通过么？？ 不会报错，可选项都有个默认值nil，编译器会生成多个初始化方法，同时它也能保证所有变量都有初始值","pubDate":"Sun, 01 Sep 2019 02:40:23 GMT","guid":"http://example.com/2019/09/01/swift-结构体和类/","category":"swift"},{"title":"swift枚举","link":"http://example.com/2019/08/28/swift枚举/","description":"一 枚举的基本用法12345678910111213141516171819202122232425enum Direction &#123; case north case south case east case west&#125;var dir = Direction.westdir = .northprint(dir)enum Season &#123; case spring, summer,autumn, winter&#125;var season = Season.summerswitch season &#123;case .spring: print(\"spring\")case .summer: print(\"summer\")case .autumn: print(\"autumn\")case .winter: print(\"winter\")&#125; 对于有限固定值的定义成枚举比较合适,比如,季节,请求状态,物流流转状态,订单状态,等等 二 关联值1234567891011121314enum Score &#123; case points(Int) case grade(Character)&#125;var score = Score.points(96)score = .grade(\"A\")switch score &#123;case let .points(point): print(point)case .grade(var grade): grade = \"B\" print(grade)&#125;//B//Program ended with exit code: 0 可在.points前面整体定义 它定义什么类型，那三个变量就是什么类型，var 或let,也可以单独定义比如.grade关联值是存储在枚举变量内存里面的 123456789101112enum Password &#123; case number(Int,Int,Int,Int) case gesture(String)&#125;var pwd = Password.number(5, 9, 8, 6)pwd = .gesture(\"13456\")switch pwd &#123;case let .number(n1, n2, n3, n4): print(n1,n2,n3,n4)case .gesture(let gesture): print(gesture)&#125; 密码有数字密码和手势密码,这两种方式是固定的,对于有限固定值我们定义成枚举,但是每个人定义设定的数字和手势密码都不同,那我们就定义几个关联值,与这个枚举进行关联","pubDate":"Wed, 28 Aug 2019 02:45:49 GMT","guid":"http://example.com/2019/08/28/swift枚举/","category":"swift"},{"title":"swift 可选项(Optional)","link":"http://example.com/2019/08/21/swift-可选项-Optional/","description":"一 可选项定义12345678910111213141516171819var name:String? = \"Jack\"name = nilvar age:Int?age = 10age = nilvar array = [1,15,40,29]func get(_ index:Int) -&gt; Int? &#123; if index &lt; 0 || index &gt;= array.count &#123; return nil &#125; return array[index]&#125;print(get(1))print(get(-1))print(get(4))//Optional(15)//nil//nil 可选项,一般也叫可选类型,它允许将值设置为nil,在类型名称后面加个问号❓来定义一个可选项, 通过打印我们看到可选项打印出来是Optional(15),那么这个Optional(15)我们该怎么用呢 二 强制解包12345var age:Int? = 10var ageInt:Int = age!ageInt += 10print(ageInt)//20//Program ended with exit code: 0 如果要从可选项中取出被包装的数据,需要使用感叹号❕ 对值为nil的可选项进行强制解包,将会产生运行时错误 判断可选项是否包含值123456let number = Int(\"123\")if number != nil&#123; print(\"字符串转换整数成功:\\(number)\")&#125; else &#123; print(\"字符串转换整数失败\")&#125;//字符串转换整数成功:Optional(123)","pubDate":"Wed, 21 Aug 2019 11:32:28 GMT","guid":"http://example.com/2019/08/21/swift-可选项-Optional/","category":"swift"},{"title":"swift函数","link":"http://example.com/2019/08/15/swift函数/","description":"一 函数的定义12345678910111213141516171819//无参有返回值func pi() -&gt; Double &#123; return 3.1415926&#125;//有参有返回值func sum(v1:Int, v2:Int) -&gt; Int &#123; return v1 + v2&#125;//无参无返回值func sayHello() -&gt; Void &#123; print(\"hello\")&#125;//有参无返回值func sayWorld(v1:Int) &#123; print(v1)&#125; 形参默认是let,也只能是let 二 函数的文档注释返回多个值12345678910111213////// 返回两个数的和 差 平均值////// - Parameter v1: 第一个整数/// - Parameter v2: 第二个整数/// - Returns: sum:Int, difference:Int, average:Int////// - Note:通过一个元组实现多返回值func calculate(v1:Int, v2:Int) -&gt; (sum:Int, difference:Int, average:Int) &#123; let sum = v1 + v2 return (sum,v1-v2, sum &gt;&gt; 1)&#125;let result = calculate(v1: 20, v2: 10) 对着函数调用按住option键即可查看注释效果 更多注释规范 点此查看","pubDate":"Thu, 15 Aug 2019 10:59:24 GMT","guid":"http://example.com/2019/08/15/swift函数/","category":"swift"},{"title":"swift流程控制","link":"http://example.com/2019/08/10/swift流程控制/","description":"一 if else12345678let age = 30if age &gt;= 22 &#123; print(\"Get married\")&#125; else if age &gt;= 18 &#123; print(\"Being a adult\")&#125; else &#123; print(\"listening tu ta zi jiao huan\")&#125; if 后面的条件可以省略小括号条件后面的大括号不可以省略if 后面的条件只能是Bool类型 二 while12345678910var num = 5while num &gt; 0 &#123; print(\"num is \\(num)\") num -= 1&#125;var num2 = -1repeat &#123; print(\"num2 is \\(num2)\")&#125; while num2 &gt; 0 repeat-while相当于C语言中的do-while从Swift3开始,去除了自增(++),自减(–)运算符,为啥去除呢,可能为了更严谨吧. 123var number = 0let b = ++ number + number++print(b) //?? 你能快速算出b是几么? swift去除自增自减,也是为了更明确简洁吧.","pubDate":"Sat, 10 Aug 2019 09:15:16 GMT","guid":"http://example.com/2019/08/10/swift流程控制/","category":"swift"},{"title":"swift基础语法","link":"http://example.com/2019/07/30/swift基础语法/","description":"一 Hello World二 注释三 常量四 标识符五 常见数据类型六 字面量七 元组一 Hellow World1234func helloworld() &#123; print(\"hello world\")&#125;print(\"你好,世界\") 12output: 你好,世界Program ended with exit code: 0 1 不用像OC那样需要main函数,Swift会将全局内的首句可执行代码作为程序入口, 其实它还是有main函数的,底层做的,不需要我们手动写了 2 相比OC我们语句后面也不用写 “ ; ”了,但是多个语句在一行还是需要的. 12345678let a = 10var b = 20b = 100//a = 100 xxxprint(a,b)10 100Program ended with exit code: 0 1 用var 定义变量, 变量可修改值 2 用let 定义常量,值不可修改 有点像javasript常 变量的定义","pubDate":"Tue, 30 Jul 2019 05:42:31 GMT","guid":"http://example.com/2019/07/30/swift基础语法/","category":"swift"},{"title":"Swift简介","link":"http://example.com/2019/07/20/Swift简介/","description":"Swift是Apple在2014年6月WWDC发布的全新编程语言，中文名和LOGO是“雨燕” Swift之父Chris Lattner pClang编译器作者、LLVM项目的主要发起人 从Apple离职后，先后跳槽到Tesla、Google p目前在Google Brain从事AI研究 历时5年发展，从Swift1.x发展到了Swift5.x版本，经历了多次重大改变，ABI终于稳定 API(Application Programming Interface):应用程序编程接口 源代码和库之间的接口ABI(Application Binary Interface):应用程序二进制接口 应用程序与操作系统之间的底层接口涉及的内容有: 目标文件格式、数据类型的大小\\布局\\对齐、函数调用约定等等 随着ABI的稳定，Swift语法基本不会再有太大的变动,截止至2019年6月，目前最新版本:Swift5.1Swift完全开源: https://github.com/apple/swift，主要采用C++编写 一 swift 编译流程首先我们要知道编译器分为前端和后端：前端：词法分析后端：生成对应平台的二进制代码 Swift与OC和C的编译流程区别：C和OC编译器的前端是Clang，也就是以前的OC代码通过Clang这个编译器的前端进行处理，转交给LLVM这个编译器的后端，最后生成ARM的二进制代码。而Swift的编译器的前端是swiftc，通过swiftc进行词法分析和语法树处理，然后交给LLVM的后端编译器，最后生成ARM格式的二进制代码Swift代码–&gt;通过swiftc生成Swift AST(Swift语法树)–&gt;Raw Swift IL(Swift特有的中间代码)–&gt;Canonical Swift IL(更简洁的Swift代码)–&gt;转交给后端生成LLVM代码–&gt;Assembly(汇编代码)–&gt;Executable(二进制代码)每个阶段具体介绍","pubDate":"Sat, 20 Jul 2019 15:00:48 GMT","guid":"http://example.com/2019/07/20/Swift简介/","category":"swift"},{"title":"微信小程序小票打印功能（以及中文乱码的解决）","link":"http://example.com/2018/11/10/微信小程序小票打印功能（以及中文乱码的解决）/","description":"因为业务需求，需要实现微信小程序连接热敏打印机打印小票。首先我要先知道微信小程序有没有蓝牙操作相关的API，然后就是如何蓝牙连接打印机，发送打印指令了。 通过查看小程序文档)，我看到微信小程序是支持蓝牙操作的但是我看到它有两个，低功耗蓝牙，蓝牙。蓝牙我们知道，低功耗蓝牙是什么东西，网上查了下，解释如下：以前可能有蓝牙1.0、蓝牙2.0、蓝牙3.0、蓝牙4.0之类的以数字结尾的蓝牙版本号，而实际上，在最新的标准中，已经不再使用数字版本号作为蓝牙版本的区分了，取而代之的是经典蓝牙与低功耗蓝牙（BLE）这两种区别低功耗蓝牙（Bluetooth Low Energy，或称Bluetooth LE、BLE，旧商标Bluetooth Smart）也称低功耗蓝牙，是蓝牙技术联盟设计和销售的一种个人局域网技术，旨在用于医疗保健、运动健身、信标、安防、家庭娱乐等领域的新兴应用。相较经典蓝牙，低功耗蓝牙旨在保持同等通信范围的同时显著降低功耗和成本.","pubDate":"Sat, 10 Nov 2018 08:07:10 GMT","guid":"http://example.com/2018/11/10/微信小程序小票打印功能（以及中文乱码的解决）/","category":"微信小程序"},{"title":"我是如何快速上手微信小程序开发的","link":"http://example.com/2017/08/23/我是如何快速上手微信小程序开发的/","description":"一 如何创建一个微信小程序二 如何搭建小程序页面三 小程序如何获取数据，处理逻辑四 如何发布小程序应用 无论是前端开发，还是后端开发，时间长了，你总会能总结出它的一些规律的，对于前端开发主要就两条，页面展现，逻辑处理。如果是全流程开发的话，那就是，如何创建项目，页面如何实现，数据获取和逻辑处理如何实现，如何打包上线。移动端或者前端，基本开发流程就这个四个步骤。所以在在前端方面去学习新一门开发技术，只要你解决了这四个问题，那一切就OK了，下面我就讲一下，我在学习微信小程序开发，如何用这四步法快速上手开发的","pubDate":"Wed, 23 Aug 2017 10:00:00 GMT","guid":"http://example.com/2017/08/23/我是如何快速上手微信小程序开发的/","category":"微信小程序"}]}